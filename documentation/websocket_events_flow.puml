@startuml websocket_events_flow

' Use modern style
skinparam monochrome false
skinparam shadowing false
skinparam defaultFontName Arial
skinparam backgroundColor white
skinparam handwritten false
skinparam sequenceMessageAlign center
skinparam sequenceGroupBorderColor #6edb71
skinparam sequenceGroupBackgroundColor #1a1b1e

actor Client
participant "WebSocket\nClient" as WSC
participant "STOMP\nHandler" as SH
participant "Controller" as CTRL
participant "Service" as SVC
database "PostgreSQL" as DB

note over WSC
  WebSocket Topics:
  1. /topic/channel/{channelId}
     - Subscribed by: Users viewing the channel
     - Events: MESSAGE_NEW, MESSAGE_EDIT, MESSAGE_DELETE,
              REACTION_ADD, REACTION_REMOVE
  
  2. /topic/user/{userId}/notifications
     - Subscribed by: Individual user
     - Events: Notifications for new messages/reactions
              in channels they're not currently viewing
end note

== Message Flows ==

' New Message
== New Message ==
Client -> CTRL: POST /api/messages
CTRL --> Client: 202 Accepted
CTRL -> SVC: createMessage()
SVC -> DB: Save message
DB --> SVC: Confirm save
SVC -> SH: Emit MESSAGE_NEW event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Update UI with new message
note right of SH
  For each channel member not viewing:
  Send to /topic/user/{userId}/notifications
end note

' Edit Message
== Edit Message ==
Client -> CTRL: PUT /api/messages/{id}
CTRL --> Client: 200 OK with updated message
CTRL -> SVC: updateMessage()
SVC -> DB: Update message
DB --> SVC: Confirm update
SVC -> SH: Emit MESSAGE_EDIT event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Update UI with edited message

' Delete Message
== Delete Message ==
Client -> CTRL: DELETE /api/messages/{id}
CTRL --> Client: 204 No Content
CTRL -> SVC: deleteMessage()
SVC -> DB: Delete message
DB --> SVC: Confirm delete
SVC -> SH: Emit MESSAGE_DELETE event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Remove message from UI

' Direct Message
== Direct Message ==
Client -> CTRL: POST /api/messages
CTRL --> Client: 202 Accepted
CTRL -> SVC: createMessage()
SVC -> DB: Save message
DB --> SVC: Confirm save
SVC -> SH: Emit MESSAGE_NEW event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Update UI with new message
note right of SH
  If recipient not viewing:
  Send to /topic/user/{recipientId}/notifications
end note

== Reaction Flows ==

' Add Reaction
== Add Reaction ==
Client -> CTRL: POST /api/messages/{id}/reactions
CTRL --> Client: 202 Accepted
CTRL -> SVC: addReaction()
SVC -> DB: Save reaction
DB --> SVC: Confirm save
SVC -> SH: Emit REACTION_ADD event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Update UI with new reaction
note right of SH
  For each channel member not viewing:
  Send to /topic/user/{userId}/notifications
end note

' Delete Reaction
== Delete Reaction ==
Client -> CTRL: DELETE /api/messages/{id}/reactions/{reactionId}
CTRL --> Client: 204 No Content
CTRL -> SVC: removeReaction()
SVC -> DB: Delete reaction
DB --> SVC: Confirm delete
SVC -> SH: Emit REACTION_REMOVE event
SH -> WSC: Broadcast to /topic/channel/{channelId}
WSC -> Client: Remove reaction from UI

note over SH
  All events use WebSocketEventDto:
  {
    type: EventType,
    channelId: UUID,
    messageId: UUID,
    entityId?: UUID,
    userId: string,
    timestamp: DateTime,
    payload: {...}
  }
end note

@enduml 